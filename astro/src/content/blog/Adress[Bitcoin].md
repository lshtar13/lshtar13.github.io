---
title: 'Bitcoin 주소에 대하여'
description: '통시적으로'
pubDate: 'Dec 02 2024'
heroImage:
  src: '/blog-placeholder-4.jpg'
  alt: ''
tags: ["Blockchain", "Bitcoin", "Adress", "Encoding"]
series: "Bitcoin"
---

* Resources
  * [Mastering Blockchain](https://github.com/bitcoinbook/bitcoinbook)을 읽고 공부한 내용을 정리한 것.
  * [블록체인 이야기](https://kwjdnjs.tistory.com/) - 위 책을 영문으로 읽고 있는데, 언어적 한계로 이해가 가지 않거나 부연 설명이 필요하다 싶은 부분은 이 블로그를 참고하고 있다. 잘 정리해 놓으셔서 보고 공부하기 좋다.

# Bitcoin Address

## Background

### Verification

비트코인에서 주소란, 특정 트랜잭션에 접근을 가능케 하는 공개키 혹은 그 대용으로 사용할 수 있는 해시값 등을 의미한다.
비트코인의 '코인'은 실재하는 객체가 아니라 트랜잭션의 출력값이다. 
이러한 출력값(Output)들은 '잠겨'있는데 이 잠금을 해제하고 트랜잭션의 입력값(Input)의 일부으로써 이용될 수 있게 하는 것,
즉 해당 비트코인을 사용할 수 있도록 하는 장치가 주소인 것이다.

따라서 어떠한 주소로 비트코인을 송금한다는 것은 실제로 어떠한 계좌로 돈을 송금하듯 이 계좌에서 저 계좌시
기록이 옮겨가는 것이 아니라, 그 주소에 맞는 개인 키를 가진 사람만 접근할 수 있는 출력값을 생성하는 것이다.

비트코인을 소비한다는 것은 이러한 출력값들을 모아, 이 출력값들의 주인이 나라는 것을 증명하고 또 다른 출력값들을은 생성하는 것이다.
주소(공개키)는 그와 짝을 이루는 개인키가 존재하는데, 이 개인키로 만들어진 서명은 해당 공개키로만 복호화해 확인할 수 있다.
이러한 속성을 출력값에 대한 소유를 증명하는데 사용한다.

출력값에 송금을 받는(출력값의 주인)의 공개키를 적어놓았다고 가정하자.
해당 출력값을 사용하는 새로운 트랜잭션을 만든 사용자는 해당 트랜잭션과 자신의 서명을 검증자에게 보낸다.
이때, 암호화(서명)할 내용은 검증받을 트랜잭션을 통해 알아낼 수 있다.
검증자는 출력값의 공개키와 수신 받은 트랜잭션의 서명을 바탕으로, 해당 서명이 출력값의 공개키와 짝을 이루는 개인키로 이루어진 것을
확인한다.

### Script

비트코인은 이러한 검증과정의 유연성을 위해(~~개인적 생각~~) 스크립트(script)라는 일종의 언어를 사용한다.
비트코인의 소유주 검증 과정은 정형화되지 않았다.
프로토콜이 여러개가 존재한다. 만약, 처음부터 특정한 프로토콜대로만 처리하게 설계하였으면 금방 한계가 드러났을 것이다.
그러나, 출력을 '잠금' 및 '해제'의 과정을 스크립트로 작성해 트랜잭션에 포함하게 하면서 여러 버전의 검증 프로토콜이 존재하게 되었다.
이러한 유연성 덕분에 잠금 및 해제에 복수의 키를 사용하는 것도 가능해지고, 공개키 원문 대신 해시값을 저장하면서
주소 공유의 편의성을 높이거나 트랜잭션의 크기를 줄일 수 있게 되었다.

이러한 스크립트는 동작이 간단하다. Data과 opcode로 이루어져있다. 좌에서 우로 명령어를 읽어들이다.
Data는 bracket으로 둘어싸여 있고, opcode들은 'OP_'의 접두사가 존재해 구별할 수 있다.
Data를 만나면 스택에 집어넣고, opcode를 만나면 현재 스택에 대하여 해당 동작을 수행한다.

아래는 [Mastering Blockchain](https://github.com/bitcoinbook/bitcoinbook)의 4장에 등장한 스크립트의 예제이다.

```Script
<Bob's signature> <Bob's public key> OP_CHECKSIG
```

OP_CHECKSIG는 공개키와 서명을 받아, 서명이 해당 공개키로 검증될 수 있는지 확인하는 명령어이다.

스택에 Bob의 서명을 넣고, 이어서 공개키를 집어넣는다.
이후 OP_CHECKSIG를 만나, 스택에서 두개의 데이터를 소비하며 검증을 실행한다.
검증에 성공하면, 1을 스택에 집어넣는다.
이 모든 과정이 종료되면, 스택에는 1만 남아 있는다.

출력과 입력 모두 각자의 스크립트를 갖는다.
트랜잭션의 검증에 있어서, 입력 스크립트는 출력 스크립트에 앞서 실행된다.
위 예제에 비춰본다면, 출력 스크립트는 `<Bob's public key> OP_CHECKSIG`이고, 입력 스크립트는 ` <Bob's signature> `이다.
이 둘을 이어 붙여 실행한다면, 해당 출력의 주인이 Bob이라는 것을 증명할 수 있다.

## Methods

스크립트의 이용으로, 여러 개의 검증 프로토콜이 존재하게 되었다.

### Pay to Public Key ([P2PK](https://kwjdnjs.tistory.com/59))

### Pay to Public Key Hash ([P2PKH](https://kwjdnjs.tistory.com/61))

### Pay to Script Hash ([P2SH](https://kwjdnjs.tistory.com/62))

### Segwit

## Encoding

### Base58check Encoding

### Bech32 Encoding
